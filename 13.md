## production
- main.c -> exec
- main.c -> main.0 --- lnk --> exec
    libs[...] -> *.o
```
gcc -c *.c
```
it creates .o files then:
```
gcc \*.o -o program
```
or
```
gcc */*.c
```
or you might if you want only compile changed files
main.c, libprocess.c, libdata.c, test.c
main.o, libprocess.o, libdata.o, test.o

- need an automated system to recompile changed sources

Need a system to atomized the deployment installation, test, ...

## Makefile: instruction for target
- is like windows installer
- make files: bash script and a4 MACRO
- make files is hard and for different targets and install before that and ...
- it is easy but jobs are complex
- use makefilegenerator

targets:
- phony : no real files on disk(is not checked)
- ordinary

## Makefile generator
- Automake
    - Autoconf -> configure.ac (sometime have .sh extension)
    - linux programs mostly use ./configure
    - m4 lang
    - configure -> Makefile 
    - Makefile -> exec
    - more tools it have
- CMake
    - CmakeLists.txt -> Makefile (automatically) -> exec
    - it is easy : `add_executable(myapp main.c)`
    - easy and straightforward (opencv used it)


## usage
-Automake
    - no configure: (configure.ac)
    - autoconf
        - ./configure --without-q  (without quantum .e.g)
        - make --with-ssl
        - make install
- cmake
    - cmake --with-ssl -j4

- ninja (doesn't get popular)


## review about fork
- lazy load (copy-on-write)
- before posix thread was only method
- only for unix systems
- forked functions causes 
- 