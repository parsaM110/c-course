## continue on pointers
- multiple pointer -> multiple ownership
- borrowing is the pointer
- smart pointer is reference counting 
- rc in rust is smart pointer
- there is only pass by reference in c 
- pass by value is in c++ and rust but not recommended 
- pass by value for large DS like array cause lots of computation
- dereference: 
```c
data = &test;
printf("%d\n", *data);
``` 
- void pointers can't be dereference 
- void pointers are used for generics, functions which get and pass pointers :
```bash
man malloc 
# give me 10byte and return me address 
# void *malloc(size_t size)

# or 
# void free(void *ptr)
# it frees the memory doesn't matter the type
```
or 
```bash
man 2 read

#ssize_t read(int fd, void *buf, size_t count);
# read 10 byte and put it in buf and the buf data type doesn't matter
```
or 
```
man qsort
```

## lvalue, rvalue, lrvalue
lvalue :
```c
*ptr = 50;
```
rvalue:
```
int v = *ptr;
```

### in C you must always pass the array size
see strcpy, qsort, write (man 2 write ) implementations

- you can also use structure

### c doesn't care about where you read, but OS have some segment in memory (attack or bug) OS stop your program ( c doesn't have runtime to stop your program)
```
print_array(A,20000);
```
echo $? 139

---------
 
 in linux the process with pid 1 is: ( is service manager of linux )
 - in old systems : /sbin/init( init system)
 - in redhat based : /lib/systemd( systemd system)
 - canonical tried to build upstart but failed 
---- 
 loading process:
 - bootloader by bios(grub) is loaded
 - bootloader load kernel in memory
 - kernel bring up first process which is `init`
 ------
 then now
 - startx : bring up x11
 - which bring up (desktop environment) session manager, windows manager
 - e.g. : KDE will bring up plasma shell
 - if you stop process 1 the system will be restart 
 - `init 6` in old linux will restart system
 - thread is a process too.
 - process has independent code, data segment , heap and stack but thread have shared heap, code and data segment  and independent stack
 - if a process exited, parent will notice and do something
 - if your program exit normally will just put status code in `$?` but if because of error and security like segmentation fault , illegal instruction it force to exit, terminal (os) will print the message
 - in freeware  you can do anything, and if you read out of bound regarding your cpu, you will get exception in cpu level or nothing 
- if your process is doing and parent(like terminal) got exited, the child will force exit (by closing systemd, everything will get closed)
- if parent says to os that I am going to close, the child will get orphan and will become child of pid 1 (init) and become a service (creating service by fork)
- if you exit child, os will notify parent and parent should process the message from os, if it doesn't do it, the child is called zombie , because os will not release the resources unless the parent process the closing message from os
- e.g. if the parent blocked on reading network , if the child got exited , the child will become zombie 
- manual services executed in terminal can become services only by forking method
- but by telling systemd you can put it in background 
- the only multi-thread solution before posix thread is fork:
```
man 2 fork
```
- fork is copy on write (lazy loading) , we do it part by part (not instant) and will not cause RAM occupied 2x

## c is two thing:

- don't exceed boundary of your variable
- free the RAM in time




